# 이론 정리

[출처](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure)

## 자료구조

#### Array

- 논리적 저장 순서와 물리적 저장 순서가 일치한다. 
- 삽입이나 삭제의 경우 최악의 경우 O(n)이 걸린다.

#### LinkedList

- 삽입과 삭제를 O(1)에 해결
- 논리적 저장 순서와 물리적 저장 순서가 일치하지 않아 **원하는 위치 탐색**에 O(n)이 걸린다.

###### 구현은 아직..

#### BST

- 탐색이 O(log n) = O(h)
- Skewed Tree가 되면 O(n)이 됨 -> Rebalancing으로 해결 (Red-Black Tree)

###### 구현 필요

#### Binary Heap

- 최대값 찾기 O(n), heapify O(log n)

###### 구현 필요

#### Red Black Tree

- BST의 확장, 동일한 노드의 갯수일 대 depth를 최소화하여 시간 복잡도를 줄이는게 핵심 아이디어
- 데이터 저장 O(log n) 소요
- Root node부터 leaf node까지의 모든 경로 중 최소 경로와 최대 경로의 크기 비율은 2보다 크지 않다. 이러한 상태를 balanced 상태라고 한다.
- 삽입, 삭제.. 복잡..

###### 구현까지는...

#### HashTable

- hash function(hash method)을 이용해 hashcode(해쉬 값)를 만들어 저장하는 방법
- hash function은 키의 전체를 참조하여 해쉬 값을 만드는게 좋다.  Collision을 최소화 해야 하기 때문

- 충돌 해결 방법 - Open Address 방식 :  Collision 발생 시 데이터를 저장할 장소를 찾아 헤맨다. Linear Probing, Quadratic Probing, Double hashing Probing 3가지가 있다.
- 충돌 해결 방법 - Separate Chaining 방식 : Open Address보다 빠르다. Open Address는 해시 버킷의 밀도가 높아질 수록 Collision이 발생할 확률이 높다. Linked List, Red-Black Tree의 2가지 방식이 있다.
- 